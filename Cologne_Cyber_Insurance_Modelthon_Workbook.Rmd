---
title: "Cyber Insurance Modelthon Workbook"
output: html_notebook
---

```{r eval=FALSE, include=FALSE}
###Run this chunk once manually in the beginnig to install the necessary packages

require("data.table")
require("tidyverse")
require("formattable")
require("actuar")
```

```{r}
#Libraries
library(data.table)
library(tidyverse)
library(formattable)
library(actuar)

wd = getwd()


#Loading DAmage, Premium and Expense Ratio Data
load(paste0(wd,"/data/Input_Data_Modelthon.RData"))

#Loading Solutions First Optimizaton
load(paste0(wd,"/data/solution_model_1.RData"))

#Loading Data for Second Optimization
load(paste0(wd,"/data/solution_model_2.RData"))

#Loading Data for premium
load(paste0(wd,"/data/premiumarray.RData"))

load(paste0(wd,"/data/71-buckets.RData"))
#Load Data constrained Optimization
load(paste0(wd,"/data/71-buckets.RData"))


#Hardcoded IW-Arrays
scenario_1_IW = c(5e3,2.5e3,1.5e3,1.25e3,0.7e3) 
scenario_2_IW = c(6:15*1e3)
scenario_3_IW = c(5e3,2.5e3,1.5e3,1.25e3,0.7e3) 

#More Information:
#Scenario 1: Standard Optimization, No Constraints
#Scenario 2: One Insurer per 
#Scenario 3: 5 Insurance Companies, First and Second constrained to Large, Third to Med, Fourth and Fifth Small & Med
```




```{r}
#' Calculate the outcomes from the best weights of the optimization and the respective weights of insurance companies 
#'
#' @author Daniel Kasper <daniel.kasper@@cyber-economics.com>
#'
#' @param weights 2-Dimensional Array with the outcomes of main simulation or manually set weights. Needs to be fed all Insurance Companies for a given model.
#' @param verification_Set Verification set with "fresh" data to verifiy to main optimization results on.Number of Rows equal to number of Columns of optimal weights for Matrix Multiplication.
#' @output Returns a list with the VaR, average return, many more summary statistics and a data.frame with the outcomes in the long (=dplyr & ggplot2 friendly) format.
#'

calculate_insurance_outcomes <- function(weights,verification_set,initial_wealth_array){
  #Get Result Dimensions from the dimension of the weight
  num_IC =  dim(weights)[3]
  num_sim_rums =  dim(weights)[1]
  result_matrix <- data.frame(matrix(ncol = num_IC, nrow = 7))
  #Write Initial Capital 
  result_matrix[1,] = initial_wealth_array
  rownames(result_matrix) <- c("Initial Wealth (IW)", "Avg. VaR 99.5% (RP2000)", "Sum of VaR-Violations", "Avg. Profit", "Model Premium", "Implied Expense Ratio", "Avg. Probability of Loss" )
  n_runs =  ncol(verification_set)
  for (i in 1:num_IC){
    
    VaR = 0 
    realized_result = 0
    model_premium_without_expense_ratio = 0 
    implied_premiums_with_expense_ratio = 0
    VaR_Penalty_Sum = 0
    probability_of_loss = 0
    
        for (k in 1:num_sim_rums){
   #Get Active weights.
           active_weight = weights[k,,i]
  
            'Calculate Return'
  returnvector <- colSums(active_weight %*% verification_set)
    
    #First Append Data, so it can be used for the reinsurance case later as well with     # a static id to map correlation.
    
        if(i*k == 1){ 
       statistical_distributions =    as.data.frame(cbind(returnvector, rep(initial_wealth_array[i], n_runs), rep(k, n_runs), c(1:n_runs)))
         colnames(statistical_distributions) <- c("Profit", "Initial_Wealth", "Simulation_Number", "Damage_Year_Epoch") 
    } else {
      new_rows = as.data.frame(cbind(returnvector, rep(initial_wealth_array[i], n_runs), rep(k, n_runs), c(1:n_runs)))
      colnames(new_rows) <- c("Profit", "Initial_Wealth", "Simulation_Number", "Damage_Year_Epoch") 
      statistical_distributions = rbind(statistical_distributions, new_rows)
      
        
      }
    

  returnvector = sort(returnvector, decreasing = T)
  #Get Number of runs to calculate Var 99.5. Algorithm: Divide n_runs by 200 and multiply this number by 199 (position of VAR) rounded up
  n_runs =  ncol(verification_set)
  VAR_position = ceiling((n_runs / 200)* 199)
  VaR <- returnvector[VAR_position] + VaR
  realized_result <- mean(returnvector)
  #Premiums need to be scaled down by 1000. The model premium is calculated by 
  model_premium_without_expense_ratio = (colSums(active_weight %*% (premium_array))) + model_premium_without_expense_ratio
  #With the expenseratio added
  implied_premiums_with_expense_ratio = (colSums(active_weight %*% (premium_array))) /0.7 + implied_premiums_with_expense_ratio
probability_of_loss = (length(returnvector[returnvector < 0]) / n_runs) + probability_of_loss

    VaR_Penalty_Sum = ifelse(initial_wealth_array[i] < -returnvector[VAR_position],1,0) + VaR_Penalty_Sum
    #Create Dataframe with data in long format. if i*k=1 (first loop) create new df, else append to existing.

    
    #End Inner Loop
        }
    
    result_matrix[2,i] = VaR / num_sim_rums
    result_matrix[3,i] = VaR_Penalty_Sum / num_sim_rums
    result_matrix[4,i] = realized_result / num_sim_rums
    result_matrix[5,i] = model_premium_without_expense_ratio / num_sim_rums
    result_matrix[6,i] = implied_premiums_with_expense_ratio / num_sim_rums
    result_matrix[7,i] = probability_of_loss / num_sim_rums
     
    
  }
  
output = list(result_matrix,statistical_distributions)
names(output) = c("Summary_Statistics", "Outcomes_Long_Format")
  return(output)
}
```




```{r}
#' Calculate the outcomes from the best weights of the optimization and the respective weights of insurance companies 
#'
#' @author Daniel Kasper <daniel.kasper@@cyber-economics.com>
#'
#' @param weights 2-Dimensional Array with the outcomes of main simulation or manually set weights. Needs to be fed all Insurance Companies for a given model. But instead of a single weight, all relevant insurance companies in a given model scenario need to be supplied, otherwise, reinsurance wouldn't make sense.
#' @param verification_Set Verification set with "fresh" data to verify to main optimization results on.Number of Rows equal to number of Columns of optimal weights for Matrix Multiplication.
#' @param reinsurance_matrix A Reinsurance matrix with number of insurance companies equal to the columns 
#' @output Returns a list with tons of good stuff!
#'
calculate_reinsurance_outcomes <- function(weights, verification_set, initial_wealth_array, reinsurance_matrix){
   #Code Equal to insurance_outcomes function at the end.
  num_IC =  dim(weights)[3]
  num_sim_rums =  dim(weights)[1]
  result_matrix <- data.frame(matrix(ncol = num_IC, nrow = 7))
  #Write Initial Capital 
  result_matrix[1,] = initial_wealth_array
  rownames(result_matrix) <- c("Initial Wealth (IW)", "Avg. VaR 99.5% (RP2000)", "Sum of VaR-Violations", "Avg. Profit", "Model Premium", "Premium with Expense Ratio", "Avg. Probability of Loss" )
  n_runs =  ncol(verification_set)
  for (i in 1:num_IC){
    
    VaR = 0 
    realized_result = 0
    model_premium_without_expense_ratio = 0 
    implied_premiums_with_expense_ratio = 0
    VaR_Penalty_Sum = 0
    probability_of_loss = 0
    
        for (k in 1:num_sim_rums){
   #Get Active weights.
           active_weight = weights[k,,i]
  
            'Calculate Return'
  returnvector <- colSums(active_weight %*% verification_set)
    
    #First Append Data, so it can be used for the reinsurance case later as well with     # a static id to map correlation.
    
        if(i*k == 1){ 
       statistical_distributions =    as.data.frame(cbind(returnvector, rep(initial_wealth_array[i], n_runs), rep(k, n_runs), c(1:n_runs), rep(i,n_runs)))
         colnames(statistical_distributions) <- c("Profit", "Initial_Wealth", "Simulation_Number", "Damage_Year_Epoch", "Number_IC")   
    } else {
      new_rows = as.data.frame(cbind(returnvector, rep(initial_wealth_array[i], n_runs), rep(k, n_runs), c(1:n_runs), rep(i,n_runs)))
      colnames(new_rows) <- c("Profit", "Initial_Wealth", "Simulation_Number", "Damage_Year_Epoch", "Number_IC") 
      statistical_distributions = rbind(statistical_distributions, new_rows)
      
        
      }
    

  returnvector = sort(returnvector, decreasing = T)
  #Get Number of runs to calculate Var 99.5. Algorithm: Divide n_runs by 200 and multiply this number by 199 (position of VAR) rounded up
  n_runs =  ncol(verification_set)
  VAR_position = ceiling((n_runs / 200)* 199)
  VaR <- returnvector[VAR_position] + VaR
  realized_result <- mean(returnvector)
  #Premiums need to be scaled down by 1000. The model premium is calculated by 
  model_premium_without_expense_ratio = (colSums(active_weight %*% (premium_array))) + model_premium_without_expense_ratio
  #With the expenseratio added
  implied_premiums_with_expense_ratio = (colSums(active_weight %*% (premium_array))) /0.7 + implied_premiums_with_expense_ratio
probability_of_loss = (length(returnvector[returnvector < 0]) / n_runs) + probability_of_loss

    VaR_Penalty_Sum = ifelse(initial_wealth_array[i] < -returnvector[VAR_position],1,0) + VaR_Penalty_Sum
    #Create Dataframe with data in long format. if i*k=1 (first loop) create new df, else append to existing.

    
    #End Inner Loop
        }
    
    result_matrix[2,i] = VaR / num_sim_rums
    result_matrix[3,i] = VaR_Penalty_Sum 
    result_matrix[4,i] = realized_result / num_sim_rums
    result_matrix[5,i] = model_premium_without_expense_ratio / num_sim_rums
    result_matrix[6,i] = implied_premiums_with_expense_ratio / num_sim_rums
    result_matrix[7,i] = probability_of_loss / num_sim_rums
    
   
    
    
  }
  
output_insurance = list(result_matrix,statistical_distributions)
names(output_insurance) = c("Summary_Statistics", "Outcomes_Long_Format")

#Start the Reinsurance specific Analysis here
#Number of reinsurance Companies
num_rc = nrow(reinsurance_matrix)

#Declare Reinsurance Matrix Summary 

  reinsurance_result_matrix <- data.frame(matrix(ncol = num_rc, nrow = 5))
  #Write Initial Capital 
  rownames(reinsurance_result_matrix) <- c("Avg. VaR 99.5% (RP2000)","Avg. Profit", "Primary Model Premium Share", "Premium with Expense Ratio", "Avg. Probability of Loss" )

for (i in 1:num_rc){

#Get Correct reinsurance weight for each company.
reinsurance_weights = cbind(c(1:num_IC),reinsurance_matrix[i])
colnames(reinsurance_weights) = c("Number_IC", "Quota_Share")

#Get the Reinsurance Losses by looking up the Quota_Shares from the reinsurer
reinsurance_outcomes = statistical_distributions %>%  ungroup() %>% left_join(reinsurance_weights, copy = T) %>% mutate(Reinsurance_profit = Quota_Share * Profit) %>% group_by(Simulation_Number,Damage_Year_Epoch) %>% summarize(reinsurance_epoch_loss = sum(Reinsurance_profit)) %>% group_by(Simulation_Number) %>% group_split

#Iterate through the simulation runs to calculate reinsurance outcomes
    VaR = 0 
    realized_result = 0
    Primary_Premium_Share =  0 
    probability_of_loss = 0
 
for(k in 1:num_sim_rums){
reinsurance_return_vector = sort(reinsurance_outcomes[[k]][["reinsurance_epoch_loss"]])

#Write Reinsurance Outcomes to Data, fit to reinsurance

        if(i*k == 1){ 
       statistical_distributions_reinsurance =    as.data.frame(cbind(returnvector, rep(paste0((reinsurance_matrix_1[i,])), n_runs), rep(k, n_runs), c(1:n_runs), rep(i,n_runs)))
         colnames(statistical_distributions_reinsurance) <- c("Profit", "List_of_Weights", "Simulation_Number", "Damage_Year/Epoch", "Number_RC")   
    } else {
      new_rows = as.data.frame(cbind(returnvector, rep(paste0((reinsurance_matrix_1[i,])), n_runs), rep(k, n_runs), c(1:n_runs), rep(i,n_runs)))
         colnames(new_rows) <- c("Profit", "List_of_Weights", "Simulation_Number", "Damage_Year/Epoch", "Number_RC") 
      statistical_distributions_reinsurance = rbind(statistical_distributions_reinsurance, new_rows)
      
        
      }
#Array is flipped_so need 
n_runs =  length(reinsurance_return_vector)
VAR_position = n_runs - ceiling((n_runs / 200)* 199)
VaR <- reinsurance_return_vector[VAR_position] + VaR
realized_result <- mean(reinsurance_return_vector)  
probability_of_loss = (length(returnvector[reinsurance_return_vector < 0]) / n_runs) + probability_of_loss
 
}
    #lazy loop
     reinsurance_premium_share  = 0
    for (j in 1:num_IC){
    reinsurance_premium_share = reinsurance_matrix[i,j] * output_insurance[[1]][5,j] + reinsurance_premium_share
    }
    reinsurance_result_matrix[1,i] = VaR / num_sim_rums
    reinsurance_result_matrix[2,i] = realized_result / num_sim_rums
    reinsurance_result_matrix[3,i] = reinsurance_premium_share
    reinsurance_result_matrix[4,i] = reinsurance_premium_share / 0.7
    reinsurance_result_matrix[5,i] = probability_of_loss / num_sim_rums


}

 output_reinsurance = list(reinsurance_result_matrix, statistical_distributions_reinsurance)

 final_output = list(output_insurance,output_reinsurance)
 names(final_output) = list("Insurance Outcomes", "Reinsurance Outcomes")



return(final_output)
}
```








```{r}
#Start Analysis



#Reinsurance Matrix 1: 4 Reinsurers, 40%, 20%, 10%, 5% quota share with all insurers.
#nrow = number of reinsurers, ncol = number of insurerance companies.
reinsurance_matrix_1 = rbind(rep(0.4,5),rep(0.2,5),rep(0.1,5),rep(0.05,5))

test_outcome1 = calculate_insurance_outcomes(Model_1_Solutions, verification_set, scenario_1_IW)
test_outcome2 = calculate_reinsurance_outcomes(Model_1_Solutions, verification_set, scenario_1_IW, reinsurance_matrix_1)

#Scenario 2 is called capital_curve. Only one Insurance Company per setup, however, multiple simulations. So we need to loop and extract the stuff we want from it 

#Dimension of capital curve, first is number of IW_setups, which gives us the duartion of the loop We need to explicitly declare the array, because if else, the last (4th) dimension of the original array gets wiped. So we just double the array, and just take the first value.


dim_cc = dim(capital_curve)[[1]]
capital_curve_pseudo_array = array(dim = c(dim(capital_curve)[[2]],dim(capital_curve)[[3]],2)) 

capital_curve_overview = matrix(nrow = 7, ncol = dim_cc)

for (i in 1:dim_cc){
  #Calculate Value and bind to new frame. First seed the pseudo array with the double rows and return
  capital_curve_pseudo_array[,,1] = capital_curve[i,,,]
  capital_curve_pseudo_array[,,2] = capital_curve[i,,,]
  current_values_cc = calculate_insurance_outcomes(capital_curve_pseudo_array, verification_set, scenario_2_IW[i])
capital_curve_overview[,i] = cbind(current_values_cc[[1]][,1])
  
}

#Scenario 3: Constrained Optimization: 5 Insurance Companies, First and Second constrained to Large, Third to Med, Fourth and Fifth Small & Med


scenario_3_results = calculate_reinsurance_outcomes(constrained_optimization_results[1,,,], verification_set_new, scenario_3_IW, reinsurance_matrix_1)


#Filter Output of Reinsurers
filter_down_reinsurance_outcomes = data.frame(test_outcome2[[2]][[2]]) %>% filter(Number_RC == "1")
```





```{r}
df_to_plot = test_outcome1$Outcomes_Long_Format
for(IW in unique(test_outcome1$Outcomes_Long_Format$Initial_Wealth)){
p = ggplot()
colors = c("red","blue","green","yellow","black")
for(simu_nb in seq(1,5)){
  df_to_plot_simu_1= df_to_plot[df_to_plot$Simulation_Number== simu_nb,]%>% filter(Initial_Wealth == IW) %>% arrange(Profit)
p = p + theme_bw() + geom_line(data = df_to_plot_simu_1,aes(y=Profit,x=seq(1,length(Profit))),color = colors[simu_nb], label = paste0("simulation_nb",str(simu_nb)))+ggtitle(paste0("Profits by simulations for initial wealth = ",IW))+ xlab(" ") 
}
#ggsave(paste0("./IW_",IW,".png"),p)
print(p)
}


```

```{r}
library(reshape)
df_to_plot = test_outcome1$Outcomes_Long_Format
df_to_plot = df_to_plot
df_to_plot
```


```{r}
df_to_plot = test_outcome1$Outcomes_Long_Format
df_melted = melt(df_to_plot,id=c("Profit"))
df_melted
```


```{r}
ggplot(df_melted) + geom_line(aes(y=value,x=seq(1,32000),color = Initial_Wealth))
```



```{r}
df_to_plot = test_outcome1$Outcomes_Long_Format
IWs = (unique(test_outcome1$Outcomes_Long_Format$Initial_Wealth))
p = ggplot()
colors = c("red","blue","green","orange","brown")
for(IW in IWs[order(IWs)]){
  df_to_plot_IW = df_to_plot[df_to_plot$Initial_Wealth == IW,]
  max_profit = max(df_to_plot_IW$Profit)
  nb_simu = df_to_plot_IW[df_to_plot_IW$Profit == max_profit,]$Simulation_Number
  df_to_plot_simu_1= df_to_plot[df_to_plot$Simulation_Number== simu_nb,]%>% filter(Initial_Wealth == IW) %>%     arrange(Profit)
p = p + theme_bw() + geom_line(data = df_to_plot_simu_1,aes(y=Profit,x=seq(1,length(Profit))),colour = IW)+ggtitle(paste0("Profits by simulations for multiple initial wealths")) + labs(x = " ", y = "Profit", 
       colour = "Initial wealth")
}

print(p)
```






```{r}
df_to_plot = test_outcome2$`Reinsurance Outcomes`[[2]]
```





```{r}
read.csv("C:/Users/yousra.cherkaoui/OneDrive - Milliman/Documents/cyber/Code/cologne_modelthon/Cologne-Cyber-Insurance-Modelthon/data/71-buckets.RData", header=TRUE, sep= " ")
```



```{r}
df_to_plot = test_outcome2$`Reinsurance Outcomes`[[2]]
p = ggplot()
colors = c("red","blue","green","yellow","black")
for(simu_nb in seq(1,5)){
  df_to_plot_simu_1= df_to_plot[df_to_plot$Simulation_Number== simu_nb,]%>% arrange(Profit)
p = p + theme_bw() + geom_line(data = df_to_plot_simu_1,aes(y=Profit,x=seq(1,length(Profit))),color = colors[simu_nb], label = paste0("simulation_nb",str(simu_nb)))+ggtitle(paste0("Profits by simulations "))+ xlab(" ") 
}
#ggsave(paste0("./IW_",IW,".png"),p)
print(p)

```





```{r}
#New Functions



calculate_reinsurance_outcomes_with_bonds <- function(insurance_outcomes, reinsurance_matrix){ 
  
  }
  


calculate_reinsurance_outcomes_with_bonds_and_backstop <- function(insurance_outcomes, reinsurance_matrix){ 
  
  }
  
  


feasibility_analayis_insurance_reinsurance


#' Plot Outcomes
#'
#' @author Daniel Kasper <daniel.kasper@@cyber-economics.com>
#'
#' @param total_outcomes Plots the outcome function, can be mu
#' @param verification_Set Verification set with "fresh" data to verifiy to main optimization results on.Number of Rows equal to number of Columns of optimal weights for Matrix Multiplication.
#' 
#'

plot_outcomes_insurance <- function(total_outcomes){
  
}

plot_outcomes_insurance_reinsurance <- function(total_outcomes){
  
}

plot_outcomes_insurance_reinsurance_ILS <- function(total_outcomes){
  
}

plot_outcomes_insurance_reinsurance_ILS_PPP <- function(total_outcomes){
  
}



```


